<!--
Web app for MIT App Inventor WebViewer
Features:
- Leaflet map (OpenStreetMap tiles)
- Gets user's location (browser geolocation)
- Fetches nearby POIs from Overpass (tourism, historic, vegetarian/vegan restaurants)
- Shows markers with popup: name, short description, estimated price, avg visit time, Play Audio button
- Plays audio in-page (mp3 URLs). You can host audio files on Firebase Storage or GitHub.
- Calculates an optimized walking route (simple nearest-neighbor heuristic) using OpenRouteService Matrix + Directions

How to use:
1) Host this file on GitHub Pages or any static host (e.g. https://username.github.io/yourrepo/)
2) Replace ORS_API_KEY with your OpenRouteService API key (https://openrouteservice.org/). No key is needed for Overpass.
3) Add or replace POI audio URLs in the `manualPOIs` array or let Overpass find POIs automatically.
4) In MIT App Inventor, create a WebViewer and set its URL to the hosted page.

Notes for App Inventor integration:
- This web app plays audio inside the page itself, so you don't need the App Inventor Player component.
- If you prefer App Inventor to handle audio, change the "Play" button to set `window.location = 'app://play?src=' + encodeURIComponent(audioUrl)` and catch the URL change in App Inventor blocks.

-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Su Travel</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-sA+e2YvGQm0t3wYk/2gq5QZb1k9QmQY6vNfYw5a0i3s=" crossorigin=""/>
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    .legend{background:white;padding:8px;border-radius:6px;box-shadow:0 1px 6px rgba(0,0,0,0.3)}
    .poi-list{max-height:200px;overflow:auto}
    .control-btn{padding:6px 10px;border-radius:6px;border:0;background:#2b7af0;color:white;cursor:pointer}
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-o9N1j7k3sC5f2y9XbYd3+FOWgJ7kG2Qk5v5Vx3uZ9+M=" crossorigin=""></script>

<script>
// CONFIG
const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjAyZThmMTM0MjAwMjRhYWE4NzEwYzlhM2Y4MTZmOTQ0IiwiaCI6Im11cm11cjY0In0='; // <-- REPLACE
const SEARCH_RADIUS = 1500; // meters
const MAX_POIS = 12; // how many POIs to show

// Manual POIs - you can prefill favorites (format below). Useful for gems and to add price/time/audio.
const manualPOIs = [
  // Example entry:
  // {id:'manual-1',name:'Hidden Garden',lat:37.3904,lon:-5.9961,desc:'Small secret garden known by locals.',price:'Free',time:'20 min', audio:'https://example.com/audio/garden_pt.mp3'}
];

// Utilities
function el(s){return document.createElement(s)}
function xhrFetch(url, opts){return fetch(url,opts).then(r=>r.ok? r.json(): Promise.reject(r))}

// Map init
const map = L.map('map', {zoomControl:true});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  maxZoom: 19, attribution: '© OpenStreetMap contributors'
}).addTo(map);

const userMarker = L.marker([0,0],{icon: L.circleMarker([0,0]).options}).addTo(map);
let poiLayer = L.layerGroup().addTo(map);
let routeLayer = L.layerGroup().addTo(map);

// Audio element for playing guides
const audioPlayer = new Audio();

// Geolocation & main flow
async function start() {
  if(!navigator.geolocation){alert('Geolocation not supported');return}
  navigator.geolocation.getCurrentPosition(async pos=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    map.setView([lat,lon],15);
    userMarker.setLatLng([lat,lon]);
    // load POIs (manual first then Overpass)
    const pois = [];
    for(const p of manualPOIs){pois.push(p)}
    const auto = await fetchPOIsOverpass(lat,lon,SEARCH_RADIUS,MAX_POIS - pois.length);
    for(const a of auto) pois.push(a);
    renderPOIs(pois, lat, lon);
  }, err=>{alert('Location denied or unavailable: '+err.message)},{enableHighAccuracy:true});
}

// Overpass query: tourism/historic and vegetarian/vegan restaurants
async function fetchPOIsOverpass(lat, lon, radius=1500, limit=10){
  const query = `
[out:json][timeout:25];
(
  node["tourism"~"museum|attraction|viewpoint|gallery|information"](around:${radius},${lat},${lon});
  node["historic"](around:${radius},${lat},${lon});
  node["amenity"="restaurant"]["cuisine"~"vegan|vegetarian"](around:${radius},${lat},${lon});
);
out center ${limit};
`;
  const res = await fetch('https://overpass-api.de/api/interpreter', {method:'POST', body:query});
  const json = await res.json();
  const out = json.elements.map(e=>{
    const name = e.tags && (e.tags.name || e.tags['name:en'] || e.tags['name:pt']) || 'Unnamed';
    const desc = e.tags && (e.tags['historic'] || e.tags['tourism'] || e.tags['description'] || '');
    const price = e.tags && (e.tags['fee'] || e.tags['entrance'] || '');
    const cuisine = e.tags && e.tags['cuisine'];
    return {id:e.id, name, lat:e.lat || e.center && e.center.lat, lon:e.lon || e.center && e.center.lon, desc, price: price || (cuisine? 'Check menu':'—'), time: estimateVisitTime(e.tags), audio:null, tags:e.tags};
  });
  return out.slice(0, limit);
}

function estimateVisitTime(tags){
  // Simple heuristic
  if(!tags) return '20-45 min';
  if(tags.tourism==='museum') return '60-120 min';
  if(tags.tourism==='viewpoint') return '10-30 min';
  if(tags.shop==='market' || tags.amenity==='marketplace') return '30-60 min';
  return '20-45 min';
}

function renderPOIs(pois, userLat, userLon){
  poiLayer.clearLayers();
  pois.forEach(p=>{
    const marker = L.marker([p.lat,p.lon]).addTo(poiLayer);
    const div = el('div');
    const title = el('strong'); title.textContent = p.name; div.appendChild(title);
    div.appendChild(el('br'));
    const descr = el('div'); descr.textContent = p.desc || ''; div.appendChild(descr);
    div.appendChild(el('br'));
    const info = el('div'); info.innerHTML = `Price: <b>${p.price || '—'}</b> &nbsp; • &nbsp; Avg Time: <b>${p.time || '—'}</b>`; div.appendChild(info);
    div.appendChild(el('br'));
    const playBtn = el('button'); playBtn.textContent = 'Play Audio Guide'; playBtn.className='control-btn';
    playBtn.onclick = ()=>{
      if(p.audio){
        playAudio(p.audio);
      } else {
        // fallback to TTS inside page
        ttsSpeak((p.desc || p.name) + '. Estimated visit time: ' + (p.time||'—'));
      }
    }
    div.appendChild(playBtn);
    marker.bindPopup(div);
  });

  // Add route button
  if(pois.length>1){
    const routeBtn = L.control({position:'topright'});
    routeBtn.onAdd = function(){
      const container = L.DomUtil.create('div','legend');
      container.innerHTML = `<button id="routeBtn" class="control-btn">Optimized walking route</button>`;
      return container;
    }
    routeBtn.addTo(map);
    setTimeout(()=>{
      document.getElementById('routeBtn').onclick = ()=> computeAndShowRoute(pois, userLat, userLon);
    },50);
  }
}

function playAudio(url){
  audioPlayer.pause();
  audioPlayer.src = url;
  audioPlayer.play().catch(e=>{console.warn('Audio play failed', e); alert('Audio playback failed. You can host audio files on HTTPS URLs.');});
}

function ttsSpeak(text){
  if('speechSynthesis' in window){
    const ut = new SpeechSynthesisUtterance(text);
    ut.lang = 'pt-PT';
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(ut);
  } else alert('No TTS available in browser');
}

// Compute optimized order (nearest neighbor) using simple distance heuristic, then call ORS directions
async function computeAndShowRoute(pois, userLat, userLon){
  routeLayer.clearLayers();
  // build coords array starting at user location
  const coords = [[userLon,userLat]]; // lon,lat for ORS
  const pts = pois.map(p=>[p.lon,p.lat]);
  // nearest neighbor ordering
  const ordered = [ [userLon,userLat] ];
  const remaining = pts.slice();
  let cur = [userLon,userLat];
  while(remaining.length){
    let bestIdx=0, bestDist=distanceKm(cur[1],cur[0],remaining[0][1],remaining[0][0]);
    for(let i=1;i<remaining.length;i++){
      const d = distanceKm(cur[1],cur[0],remaining[i][1],remaining[i][0]);
      if(d<bestDist){bestDist=d;bestIdx=i}
    }
    const next = remaining.splice(bestIdx,1)[0];
    ordered.push(next);
    cur = next;
  }
  // build coordinates string for ORS directions
  const coordinates = ordered.map(c=>[c[0],c[1]]); // lon,lat pairs
  // call ORS directions (walking) with geojson geometry
  const body = {coordinates: coordinates, format:'geojson', instructions:true};
  try{
    const dirs = await fetch('https://api.openrouteservice.org/v2/directions/foot-walking/geojson',{
      method:'POST', headers:{'Content-Type':'application/json','Authorization':ORS_API_KEY}, body: JSON.stringify(body)
    }).then(r=>r.json());
    // draw
    L.geoJSON(dirs, {style:{color:'#2b7af0',weight:5,opacity:0.8}}).addTo(routeLayer);
    // add numbered markers
    for(let i=0;i<ordered.length;i++){
      const lon = ordered[i][0], lat = ordered[i][1];
      const m = L.marker([lat,lon], {title: (i===0? 'Start':'Stop '+i)}).addTo(routeLayer);
      m.bindTooltip(i===0? 'Start': String(i));
    }
    map.fitBounds(routeLayer.getBounds(),{padding:[40,40]});
  }catch(err){console.error(err);alert('Error fetching route from OpenRouteService. Check API key and quotas.')}
}

// basic haversine
function distanceKm(lat1,lon1,lat2,lon2){
  const R=6371; const dLat=(lat2-lat1)*Math.PI/180; const dLon=(lon2-lon1)*Math.PI/180;
  const a = Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); return R*c;
}

// Optional: allow passing lat/lon via query parameters (from App Inventor)
function getQueryParams(){
  const q = {};
  location.search.substring(1).split('&').forEach(p=>{const kv=p.split('='); if(kv[0]) q[kv[0]]=decodeURIComponent(kv[1]||'')});
  return q;
}

// If the page is loaded with ?lat=...&lon=... we center there immediately and run search
window.addEventListener('load', ()=>{
  const q = getQueryParams();
  if(q.lat && q.lon){
    const lat = parseFloat(q.lat), lon = parseFloat(q.lon);
    map.setView([lat,lon],15);
    userMarker.setLatLng([lat,lon]);
    fetchPOIsOverpass(lat,lon,SEARCH_RADIUS,MAX_POIS).then(pois=>renderPOIs(pois,lat,lon));
    return;
  }
  start();
});

</script>
</body>
</html>
